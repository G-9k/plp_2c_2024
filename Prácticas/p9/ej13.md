# Ejercicio 13


```smalltalk
aCounter := FlexibleCounter new: [:v | v+2 ]. aCounter nextIf: true.
```


| Receptor                    | Mensaje          | Colaborador        | Clase           | Resultado    |
| --------                    | -------          | -----------        | -----           | ---------    | 
| FlexibleCounter             | new:             | [:v \| v+2]        | FlexibleCounter | unFC         | 
| FlexibleCounter (super)     | new              | -                  | Counter         | unFC         |
| FlexibleCounter (super)     | new              | -                  | Object          | unFC         |
| unFC                        | initialize:      | 0                  | Counter [^1]    | unFC [^2]    |
| unFC                        | useBlock:        | [:v \| v+2]        | FlexibleCounter | unFC [^3]    |
| aCounter [^4]               | nextIf:          | true.              | Counter [^1]    | ? (2)        |
| true                        | ifTrue: ifFalse: |[self next], [count]| True           | ? (2)        |
| aCounter (self)             | next             | -                  | FlexibleCounter | ? (2)        |
| block ([:v \| v+2])         | value:           | count (0)          | blockClosure    | 2            |
| aCounter (self)             | initialize       | 2                  | Counter [^1]    | aCounter [^5]|



Al final de todo, retorna 2 la evaluaci贸n.


[^1]: Lo bucamos en FlexibleCounter, pero al no estar el look up ejecuta el metodo que encuentra en la superclase

[^2]: Variable de instancia |count| seteada en 0

[^3]: Variable de instancia |block| seteada en [:v \| v+2]

[^4]: En este punto ya se ejecut贸 la asignaci贸n `aCounter := FlexibleCounter new: [:v | v+2 ]`. Y por eso llamo a la instancia de FlexibleCounter con el nombre que se le asign贸.

[^5]: Variable de instancia |count| seteada en 2 (el resultado es la misma instancia porque retorna self)








